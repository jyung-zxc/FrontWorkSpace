<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <h1>Function</h1>
    <h2>함수작성</h2>

    <script>

        //.함수선언식 -> 호이스팅된다.
        function foo() {

        }

        //함수표현식 -> 호이스팅x
        var bar = function () { };
        bar(); // 함수표현식의 함수는 반드시 작성도니 이후에 호출해야한다.

        // 즉시실행함수(IIFE)
        // - IIFE (Immediately Invoked Function Expression)
        // - 1회용 함수를 작성하고 싶을떄 사용
        // - (함수){};

        (function () {
            console.log("hello");
        })();

        (function () {
            console.log('bye js');
        }());

        (function (name) {
            console.log("hello" + name);
        })('철수');


    </script>

    <h2>매개변수 | 매개인자</h2>
    <input type="button" value="실행" onclick="test1();">
    <input type="button" value="실행" onclick="test2();">

    <script>

        // 매개변수(paramether): 함수선언시 매개인자가 담길 공간
        // 매개인자 ( argument) : 함수호출시 전달할 값
        // 자바스키릅테어스는 매개변수의 개수가 달라도 문제되지 안는다.
        function test1(y) {
            console.log("x = ", x);

            //모든 함수는 묵시적으로 arguments배열을 가지고 있다.
            console.test1();

        }

        function test2() {
            // 매개인자의 합을 출력하는 add메서드 작성
            add(1, 2, 3, 4, 5, 6, 7, 8, 9, 10); //55출력
            add(12, 34, 56, 78) // 58.01
            add('a', 'b', 'c', 'd'); // abcd 출력
        }

        function add() {
            var sum = typeof (arguments[0]) == 'number' ? 0 : "";
            for (var i = 0; i < arguments.length; i++) {
                sum += arguments[i];
            }
            if (typeof (arguments[0]) == 'number') {
                sum = Math.floor(sum * 100) / 100;
            }
            console.log(sum);
        }
    </script>

    <h2>함수 특징</h2>
    <input type="button" value="return value" onclick="test3()" >
    <input type="button" value="중첩 함수" onclick=" test4(10,5)">

    <script>
        // 함수의 return구문이 없거나, return 뒤쪽에
        // 반환할 값이 없는 경우 undefined를 반환
        function test3(){
            var k = koo();
            console.log(k);
        }

        function koo(){
            return 100;
            return;
        }

        // a^2 + b^2 = c^2;
        function test4(a,b){

            var c;
            
            var power = function (n){
                return n **2;
            }

            // ** 지수연산자(제곱)
            c = Math.sqrt(a ** 2 + b ** 2);
            console.log(c);
        }

    </script>

    <h2>고급 함수</h2>
    <input type="button" value="매개인자" onclick="test5()">
    <input type="button" value="ㄹㄹ" onclick="test6()">

    <script>
        /*

       unescape자바스크립트에서는 함수는 "값으로 취급된다."
        1. 변수에 대입할수있고
        2. 함수의 매개인자로 전달될수있고
        리턴값으로 사용가능 */

        function exec(fn){
            
        }

        function test5(){
            // 함수를 리턴값으로 사용하기
        }

        function test6(){
            var hello = refurnFunction('hello;');
            hello('js');

            refurnFunction("goodbye")("js");
        }

        function refurnFunction(say){
            returnfunction(name);{
                // var say = say;
                console.log(say+" "+name);
            }
        };

    </script>

    <h2>Closure</h2>
    <input type="button" value="globalCounter" onclick="test7()">
    <input type="button" value="closureCounter1" onclick="test8()">
    <input type="button" value="closureCounter2" onclick="test9()">

    <script>
        var cnt = 0; // 전역변수(Global/script soope)
        function test7(){
            // local scope(함수 내부의 스코프)
            // debugger;
            var cnt = 0;
            console.log("global : "+ ++cnt);
        }

         /* 
            클로저(Closure)
             - 중첩함수에서 하위 함수가, 상위함수의 변수를 참조할 때 생겨나는 스코프
             - 하위함수에서 상위함수의 변수값을 참조하는 경우 , 
               하위함수의 closure스코프에 변수값을 추가한다.
             - 클로져로 인해, stack메모리에서 상위함수의 메모리가 제거되더라도
             상위함수의 변수를 그대로 가져다 사용할 수 있다.
         */


         function funcY(){
            var num = 100;
            function funcZ(){
                debugger;
                console.log("num=", num);
            }
            return funcZ;
         }
         const myFn = funcY();
        //  myFn();

        function makeClosureCounter(){
            var cnt = 0;
            return function(){
                console.log('closureScope : ' + ++cnt);
            }
        }

        var test8 = makeClosureCounter();
        var test9 = makeClosureCounter();
    </script>




</body>

</html>